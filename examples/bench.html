<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Test</title>
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css"
          crossorigin="anonymous">
</head>
<body>

<div class="container">
    <h1 id="title">WS NATS Browser Performance</h1>
    <label for="server">NATS Websocket Proxy</label>
    <input type="text" class="form-control" id="server" placeholder="server" autocomplete="off"
           value="{{WSURL}}"><br/>
    <label for="subject">Subject</label>
    <input type="text" class="form-control" id="subject" placeholder="subject" autocomplete="off" value="foo"><br/>
    <label for="count">Count</label>
    <input type="number" class="form-control" id="count" placeholder="messages" autocomplete="off"
           value="100000"><br/>
    <label for="payload">Payload size</label>
    <input type="number" class="form-control" id="payload" placeholder="payload size in bytes" autocomplete="off"
           value="0"><br/>

    <h3>Test</h3>
    <div class="radio-inline">
        <label><input class="form-check-input" type="radio" value="pubsub" checked id="pubsub"
                      name="test">Pub/Sub</label>
    </div>
    <div class="radio-inline">
        <label><input class="form-check-input" type="radio" value="pub" id="pub" name="test">Publish</label>
    </div>
    <div class="radio-inline">
        <label><input class="form-check-input" type="radio" value="sub" id="sub" name="test">Subscribe</label>
    </div>
    <div class="radio-inline">
        <label><input class="form-check-input" type="radio" value="sub" id="reqrep" name="test">ReqRep</label>
    </div>

    <br/><br/>
    <button id="send" onclick="run()" class="btn btn-primary">Start</button>
</div>
<br/>
<div class="container">
    <pre id="results"></pre>
</div>


<script src="../index.js"></script>

<script>
    const Payload = nats.Payload;

    function getString(id) {
        return document.getElementById(id).value;
    }

    function isChecked(id) {
        return document.getElementById(id).checked;
    }

    function getTestChoice() {
        if (isChecked("pubsub")) {
            return "pubsub";
        } else if (isChecked("pub")) {
            return "pub";
        } else if (isChecked("sub")) {
            return "sub";
        } else if (isChecked("reqrep")) {
            return "reqrep";
        }
    }

    function getNumber(id) {
        let v = getString(id);
        if (!isNaN(v)) {
            return parseInt(v, 10);
        }
        return -1
    }

    function setResults(s) {
        document.getElementById('results').innerHTML = s;
    }

    async function run() {
        let test = getTestChoice();
        switch (test) {
            case "pub":
                pub();
                break;
            case "sub":
                sub();
                break;
            case "pubsub":
                pubsub();
                break;
            case "reqrep":
                reqrep();
                break;
        }
    }

    function getOpts() {
        return {
            server: getString('server'),
            subject: getString('subject'),
            count: getNumber('count'),
            start: 0,
            end: 0,
            payload: getPayload(),
            debug: true
        };
    }

    function getPayload() {
        let size = getNumber('payload');
        if (size) {
            let ba = new Uint8Array(size);
            window.crypto.getRandomValues(ba);
            return ba;
        }
        return undefined;
    }

    function formatReport(test, opts) {
        let time = opts.end - opts.start;
        let count = Number(opts.count).toLocaleString();
        let times = Number(time).toLocaleString();
        let rps = parseInt(opts.count / (time / 1000), 10);
        let rate = Number(rps).toLocaleString();

        return `${test} ${count} msgs in ${times} ms (${rate} msgs/sec)`;
    }


    async function pub() {
        let opts = getOpts();
        try {
            setResults('working...');
            let nc = await nats.connect({url: opts.server, payload: Payload.BINARY});
            opts.start = Date.now();
            for (let i = 0; i < opts.count; i++) {
                nc.publish(opts.subject, opts.payload);
            }
            await nc.flush();
            opts.end = Date.now();
            nc.close();
            setResults(formatReport("pub", opts));
        } catch (ex) {
            setResults(ex);
        }
    }

    async function sub() {
        let opts = getOpts();
        try {
            let nc = await nats.connect({url: opts.server, payload: Payload.BINARY});
            let received = 0;
            await nc.subscribe(opts.subject, () => {
                if (received === 0) {
                    setResults('working...');
                    opts.start = Date.now();
                }
                received++;
                if (received >= opts.count) {
                    opts.end = Date.now();
                    nc.close();
                    setResults(formatReport('sub', opts));
                }
            }, {max: opts.count});
            await nc.flush();
            setResults('waiting for messages...');
        } catch (ex) {
            setResults(ex);
        }
    }

    async function pubsub() {
        let opts = getOpts();
        try {
            setResults('working...');
            let nc = await nats.connect({url: opts.server, payload: Payload.BINARY});
            nc.addEventListener('error', (err) => {
                console.error(err);
            });

            let received = 0;
            await nc.subscribe(opts.subject, () => {
                received++;
                if (received >= opts.count) {
                    opts.end = Date.now();
                    nc.close();
                    setResults(formatReport("pubsub", opts));
                }
            }, {max: opts.count});
            nc.flush();

            opts.start = Date.now();
            for (let i = 0; i < opts.count; i++) {
                nc.publish(opts.subject, opts.payload);
            }
        } catch (ex) {
            setResults(ex);
        }
    }

    async function reqrep() {
        let opts = getOpts();
        try {
            setResults('working...');
            let nc = await nats.connect({url: opts.server, payload: Payload.BINARY});
            nc.addEventListener('error', (err) => {
                console.error(err);
            });

            await nc.subscribe(opts.subject, (m) => {
                nc.publish(m.reply);
            }, {max: opts.count});
            await nc.flush();

            let futures = [];
            opts.start = Date.now();
            for (let i = 0; i < opts.count; i++) {
                let f = nc.request(opts.subject, 200000);
                futures.push(f);
            }
            await Promise.all(futures);
            opts.end = Date.now();
            setResults(formatReport("reqrep", opts));

        } catch (ex) {
            setResults(ex);
        }
    }
</script>

</body>
</html>




